{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Dora"},{"location":"/index.html#dora","text":"This is the introduction for dora library.\nOverview introduction Usage Configuration","title":"Dora"},{"location":"/overview.html","text":"","title":"Overview"},{"location":"/overview.html#overview","text":"","title":"Overview"},{"location":"/overview.html#dora","text":"Dora is a job manage system which will handle the job request in reactive way.","title":"Dora"},{"location":"/overview.html#dependency","text":"sbt libraryDependencies += \"io.github.wherby\" % \"dora_2.13\" % \"1.8.0.7.006\" Maven <dependency>\n  <groupId>io.github.wherby</groupId>\n  <artifactId>dora_2.13</artifactId>\n  <version>1.8.0.7.006</version>\n</dependency> Gradle dependencies {\n  compile group: 'io.github.wherby', name: 'dora_2.13', version: '1.8.0.7.006'\n}","title":"Dependency"},{"location":"/overview.html#whats-the-problem-the-library-resolve-","text":"The library provide a reactive way to handle resource consuming(CPU, Memory, DB connection) tasks.\nFor example, an OCR application which will trigger OCR tasks based on requests, for each OCR task there needs one CPU core occupied. If there is no implementation of job management, the CPUs will be easily taken by OCR jobs. The CPU competition will easily slow down the processing and block other function.\nWhat’s the traditional way to solve the issue is create a job queue, and use a worker to takes job from the queue.\nIs there any universal way to resolve this type of question and makes the implementation easy to use?\nYes, just use the Dora library.","title":"What’s the problem the library resolve?"},{"location":"/overview.html#how-the-dora-library-works-","text":"Simple version:\nThe Dora library use a queue to keep job requests and FSMActor will pull job request to process.\nIs the same way as traditional way?\nYes, but not, because the user will not aware of the library implementation. The example shows user call the job api. The Dora library will handle the travail work.","title":"How the Dora library works?"},{"location":"/overview.html#quick-start","text":"To use dora library to handle request see:\nrun job sync \"start and run command \" in {\n  val backendServer = BackendServer.startup(Some(1600))\n  backendServer.registFSMActor()\n  val msg = TestVars.processCallMsgTest\n  val processJob = JobMsg(\"SimpleProcess\", msg)\n  val res = BackendServer.runProcessCommand(processJob).map {\n    res =>\n      println(res)\n      assert(true)\n  }\n  Await.ready(res, ConstVars.timeout1S * 10)\n} run job async \"start the command and qurey result \" in {\n  ProcessService.nameToClassOpt = ProcessServiceSpec.safeProcessServiceNameToClassOpt\n  val backendServer = BackendServer.startup(Some(1600))\n  backendServer.registFSMActor()\n  val msg = TestVars.processCallMsgTest\n  val processJob = JobMsg(\"SimpleProcess\", msg)\n  val receiveActor = BackendServer.startProcessCommand(processJob).get\n  val res= BackendServer.queryProcessResult(receiveActor).map {\n    result =>\n      (result.result.asInstanceOf[ProcessResult]).jobStatus shouldBe (JobStatus.Finished)\n      println(result)\n  }\n\n  Await.ready(res, ConstVars.timeout1S*4)\n}\nFor more usage see : BackendSpec.scala","title":"Quick start"},{"location":"/introduction/index.html","text":"","title":"introduction"},{"location":"/introduction/index.html#introduction","text":"","title":"introduction"},{"location":"/introduction/index.html#message-flow","text":"","title":"Message flow"},{"location":"/introduction/index.html#jobrequest-flow","text":"","title":"JobRequest flow"},{"location":"/introduction/index.html#jobrequest","text":"case class JobRequest(\n      taskMsg: JobMsg,\n      replyTo: ActorRef,\n      tranActor: ActorRef,\n      priority: Option[Int] = None,\n      jobMetaOpt: Option[JobMeta] = None\n  )","title":"JobRequest"},{"location":"/introduction/index.html#receiveactor","text":"The AskProcessResult using ReceiveActor create a API to trigger jobrequest call of ( jobRequest: JobRequest, driver: ActorRef, receiveActor: ActorRef, timeout: Timeout) =>Future[JobResult], and ReceiveActor is “RequestActor” in the JobRequest work flow chat.\nAskProcessResult package doracore.api\n\nimport akka.actor.{ActorRef, PoisonPill}\nimport akka.event.slf4j.Logger\nimport akka.util.Timeout\nimport doracore.core.msg.Job.{JobRequest, JobResult, JobStatus}\nimport doracore.tool.receive.ReceiveActor.{FetchResult, ProxyControlMsg}\n\nimport scala.concurrent.{ExecutionContext, Future}\nimport akka.pattern.ask\nimport doracore.util.ProcessService.ProcessResult\n\ntrait AskProcessResult {\n  this: GetBlockIOExecutor =>\n  def getProcessCommandFutureResult(\n      jobRequest: JobRequest,\n      driver: ActorRef,\n      receiveActor: ActorRef,\n      timeout: Timeout\n  ): Future[JobResult] = {\n    driver.tell(jobRequest, receiveActor)\n    getResult(receiveActor, timeout)\n  }\n  def getResult(receiveActor: ActorRef, timeout: Timeout): Future[JobResult] = {\n    implicit val ex: ExecutionContext  = getBlockDispatcher()\n    implicit val timeoutValue: Timeout = timeout\n    var result                         = JobResult(JobStatus.Unknown, \"Unkonwn\").asInstanceOf[Any]\n    (receiveActor ? FetchResult())\n      .map { resultT =>\n        resultT.asInstanceOf[JobResult]\n      }\n      .recover { case ex: Throwable =>\n        val tName = Thread.currentThread.getName\n        Logger.apply(this.getClass.getName).error(s\"$tName=> Job timeout after $timeout\")\n        result = JobResult(JobStatus.TimeOut, ProcessResult(JobStatus.Failed, ex))\n        receiveActor ! ProxyControlMsg(result)\n        Thread.sleep(100)\n        result.asInstanceOf[JobResult]\n      }\n      .map { result =>\n        receiveActor ! ProxyControlMsg(PoisonPill)\n        receiveActor ! PoisonPill\n        result\n      }\n  }\n} ReceiveActor package doracore.tool.receive\n\nimport akka.actor.{ActorRef, Props}\nimport doracore.base.BaseActor\nimport doracore.core.driver.DriverActor.ProxyActorMsg\nimport doracore.core.msg.Job.JobResult\nimport doracore.tool.receive.ReceiveActor.{FetchResult, ProxyControlMsg, QueryResult}\n\n/** For doradilla.tool.receive in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/13\n  */\nclass ReceiveActor extends BaseActor {\n  var retriverActorOpt: Option[ActorRef] = None\n  var jobResultOpt: Option[JobResult]    = None\n  var proxyActorOpt: Option[ActorRef]    = None\n\n  def sendBackReuslt() = {\n    retriverActorOpt.get ! jobResultOpt.get\n  }\n\n  def handleFetchMsg() = {\n    retriverActorOpt = Some(sender())\n    jobResultOpt match {\n      case Some(jobResult) => sendBackReuslt()\n      case _               =>\n    }\n  }\n\n  def handleJobResult(jobResult: JobResult) = {\n    jobResultOpt = Some(jobResult)\n    retriverActorOpt match {\n      case Some(retriverActor) => sendBackReuslt()\n      case _                   =>\n    }\n  }\n\n  def handleProxyActorMsg(msg: ProxyActorMsg) = {\n    proxyActorOpt = Some(msg.proxyActor)\n  }\n\n  def handleProxyControlMsg(proxyControlMsg: ProxyControlMsg) = {\n    proxyActorOpt.map { proxyActor =>\n      proxyActor ! proxyControlMsg.proxyControlMsg\n    }\n  }\n\n  def handleQueryResult() = {\n    sender() ! jobResultOpt\n  }\n\n  override def receive: Receive = {\n    case msg: FetchResult                 => handleFetchMsg()\n    case jobResult: JobResult             => handleJobResult(jobResult)\n    case proxyActorMsg: ProxyActorMsg     => handleProxyActorMsg(proxyActorMsg)\n    case queryResult: QueryResult         => handleQueryResult()\n    case proxyControlMsg: ProxyControlMsg => handleProxyControlMsg(proxyControlMsg)\n  }\n}\n\nobject ReceiveActor {\n  val receiveActorProps = Props(new ReceiveActor())\n  case class FetchResult()\n  case class StopProxy()\n  case class QueryResult()\n  case class ProxyControlMsg(proxyControlMsg: Any)\n}","title":"ReceiveActor"},{"location":"/introduction/index.html#cluster-setup","text":"Cluster feature is not applied in the dora lib.","title":"Cluster setup"},{"location":"/introduction/messageflow.html","text":"","title":"Message flow"},{"location":"/introduction/messageflow.html#message-flow","text":"","title":"Message flow"},{"location":"/introduction/messageflow.html#jobrequest-flow","text":"","title":"JobRequest flow"},{"location":"/introduction/messageflow.html#jobrequest","text":"case class JobRequest(\n      taskMsg: JobMsg,\n      replyTo: ActorRef,\n      tranActor: ActorRef,\n      priority: Option[Int] = None,\n      jobMetaOpt: Option[JobMeta] = None\n  )","title":"JobRequest"},{"location":"/introduction/messageflow.html#receiveactor","text":"The AskProcessResult using ReceiveActor create a API to trigger jobrequest call of ( jobRequest: JobRequest, driver: ActorRef, receiveActor: ActorRef, timeout: Timeout) =>Future[JobResult], and ReceiveActor is “RequestActor” in the JobRequest work flow chat.\nAskProcessResult package doracore.api\n\nimport akka.actor.{ActorRef, PoisonPill}\nimport akka.event.slf4j.Logger\nimport akka.util.Timeout\nimport doracore.core.msg.Job.{JobRequest, JobResult, JobStatus}\nimport doracore.tool.receive.ReceiveActor.{FetchResult, ProxyControlMsg}\n\nimport scala.concurrent.{ExecutionContext, Future}\nimport akka.pattern.ask\nimport doracore.util.ProcessService.ProcessResult\n\ntrait AskProcessResult {\n  this: GetBlockIOExecutor =>\n  def getProcessCommandFutureResult(\n      jobRequest: JobRequest,\n      driver: ActorRef,\n      receiveActor: ActorRef,\n      timeout: Timeout\n  ): Future[JobResult] = {\n    driver.tell(jobRequest, receiveActor)\n    getResult(receiveActor, timeout)\n  }\n  def getResult(receiveActor: ActorRef, timeout: Timeout): Future[JobResult] = {\n    implicit val ex: ExecutionContext  = getBlockDispatcher()\n    implicit val timeoutValue: Timeout = timeout\n    var result                         = JobResult(JobStatus.Unknown, \"Unkonwn\").asInstanceOf[Any]\n    (receiveActor ? FetchResult())\n      .map { resultT =>\n        resultT.asInstanceOf[JobResult]\n      }\n      .recover { case ex: Throwable =>\n        val tName = Thread.currentThread.getName\n        Logger.apply(this.getClass.getName).error(s\"$tName=> Job timeout after $timeout\")\n        result = JobResult(JobStatus.TimeOut, ProcessResult(JobStatus.Failed, ex))\n        receiveActor ! ProxyControlMsg(result)\n        Thread.sleep(100)\n        result.asInstanceOf[JobResult]\n      }\n      .map { result =>\n        receiveActor ! ProxyControlMsg(PoisonPill)\n        receiveActor ! PoisonPill\n        result\n      }\n  }\n} ReceiveActor package doracore.tool.receive\n\nimport akka.actor.{ActorRef, Props}\nimport doracore.base.BaseActor\nimport doracore.core.driver.DriverActor.ProxyActorMsg\nimport doracore.core.msg.Job.JobResult\nimport doracore.tool.receive.ReceiveActor.{FetchResult, ProxyControlMsg, QueryResult}\n\n/** For doradilla.tool.receive in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/13\n  */\nclass ReceiveActor extends BaseActor {\n  var retriverActorOpt: Option[ActorRef] = None\n  var jobResultOpt: Option[JobResult]    = None\n  var proxyActorOpt: Option[ActorRef]    = None\n\n  def sendBackReuslt() = {\n    retriverActorOpt.get ! jobResultOpt.get\n  }\n\n  def handleFetchMsg() = {\n    retriverActorOpt = Some(sender())\n    jobResultOpt match {\n      case Some(jobResult) => sendBackReuslt()\n      case _               =>\n    }\n  }\n\n  def handleJobResult(jobResult: JobResult) = {\n    jobResultOpt = Some(jobResult)\n    retriverActorOpt match {\n      case Some(retriverActor) => sendBackReuslt()\n      case _                   =>\n    }\n  }\n\n  def handleProxyActorMsg(msg: ProxyActorMsg) = {\n    proxyActorOpt = Some(msg.proxyActor)\n  }\n\n  def handleProxyControlMsg(proxyControlMsg: ProxyControlMsg) = {\n    proxyActorOpt.map { proxyActor =>\n      proxyActor ! proxyControlMsg.proxyControlMsg\n    }\n  }\n\n  def handleQueryResult() = {\n    sender() ! jobResultOpt\n  }\n\n  override def receive: Receive = {\n    case msg: FetchResult                 => handleFetchMsg()\n    case jobResult: JobResult             => handleJobResult(jobResult)\n    case proxyActorMsg: ProxyActorMsg     => handleProxyActorMsg(proxyActorMsg)\n    case queryResult: QueryResult         => handleQueryResult()\n    case proxyControlMsg: ProxyControlMsg => handleProxyControlMsg(proxyControlMsg)\n  }\n}\n\nobject ReceiveActor {\n  val receiveActorProps = Props(new ReceiveActor())\n  case class FetchResult()\n  case class StopProxy()\n  case class QueryResult()\n  case class ProxyControlMsg(proxyControlMsg: Any)\n}","title":"ReceiveActor"},{"location":"/introduction/cluster.html","text":"","title":"Cluster setup"},{"location":"/introduction/cluster.html#cluster-setup","text":"Cluster feature is not applied in the dora lib.","title":"Cluster setup"},{"location":"/usage/index.html","text":"","title":"Usage"},{"location":"/usage/index.html#usage","text":"JobApi What’s JobApi Named job What’s named job Usage FSMActor number control for named JobApi Use case JobApi for processor control Named job usage","title":"Usage"},{"location":"/usage/jobapi.html","text":"","title":"JobApi"},{"location":"/usage/jobapi.html#jobapi","text":"","title":"JobApi"},{"location":"/usage/jobapi.html#whats-jobapi","text":"JobApi is an interface and mixin of implementation of key functions in doradilla.\nLet’s see what’s JobApi:\npackage doracore.api\n\nimport akka.actor.ActorSystem\n\n/** For doradilla.api in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/13\n  */\nclass JobApi(systemOpt: Option[ActorSystem] = None)\n    extends SystemApi(systemOpt: Option[ActorSystem])\n    with DriverApi\n    with CommandTranApi\n    with ProcessTranApi {}\nThe Job Api mixin SystemApi, DriverApi and TranslationApi(CommmandTranApi and ProcessTranApi).\nWhen create a JobApi:\nIf no AkkaSystem is passed in, there will create a AkkaSystem; if an AkkaSystem is passed in, the AkkaSystem will be used. [SystemApi] A DriveActor will be created in the AkkaSystem. And a QueueActor will created by the DriverActor. A FSMActor will be created and linked to the QueueActor [DriverApi] Some default TranslationActor(CommandTranActor, ProcessTranActor) will be created.[CommandTranApi, ProcessTranApi]\nCode implementation:\nSystemApi package doracore.api\n\nimport akka.actor.ActorSystem\nimport akka.util.Timeout\nimport doracore.util.{CNaming, ConfigService, DoraCoreConfig}\nimport doracore.vars.ConstVars\n\n/** For doradilla.api in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/9\n  */\nclass SystemApi(systemOpt: Option[ActorSystem] = None)\n    extends GetBlockIOExecutor\n    with ActorSystemApi {\n  val longTimeout = Timeout(ConstVars.longTimeOut)\n\n  lazy val doradillaConfig = DoraCoreConfig.getConfig()\n\n  def createDoradillaSystem: ActorSystem = {\n    val actorSystemName = ConfigService\n      .getStringOpt(doradillaConfig, \"doradillaSystem\")\n      .getOrElse(CNaming.timebasedName(\"doradilla\"))\n    ActorSystem(actorSystemName, doradillaConfig)\n  }\n\n  override def getActorSystem(): ActorSystem = {\n    actorSystem\n  }\n\n  val actorSystem: ActorSystem = systemOpt match {\n    case Some(system) => system\n    case _            => createDoradillaSystem\n  }\n} DriverApi package doracore.api\n\nimport akka.actor.{ActorRef}\nimport doracore.core.driver.DriverActor\nimport doracore.util.{CNaming, ConfigService}\n\n/** For doradilla.api in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/9\n  */\ntrait DriverApi {\n  this: SystemApi =>\n  def createDriver(\n      queueActorOpt: Option[ActorRef] = None,\n      driverNameOpt: Option[String] = None\n  ): ActorRef = {\n    val driverName = driverNameOpt match {\n      case Some(driverName) => driverName\n      case _ =>\n        ConfigService\n          .getStringOpt(doradillaConfig, \"driverPrefix\")\n          .getOrElse(CNaming.timebasedName(\"driver\"))\n    }\n    actorSystem.actorOf(DriverActor.driverActorProps(queueActorOpt), driverName)\n  }\n\n  var queueActorSet: Option[ActorRef] = None\n\n  lazy val defaultDriver: ActorRef = createDriver(queueActorSet)\n} CommandTranApi package doracore.api\n\nimport doracore.core.msg.Job.{JobMsg, JobRequest, JobResult}\nimport doracore.tool.job.command.CommandTranActor\nimport doracore.tool.job.command.CommandTranActor.CommandRequest\nimport doracore.tool.receive.ReceiveActor\nimport play.api.libs.json.Json\nimport scala.concurrent.{ExecutionContext, Future}\nimport akka.util.Timeout\nimport doracore.util.CNaming\n\n/** For doradilla.api in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/13\n  */\ntrait CommandTranApi extends AskProcessResult {\n  this: SystemApi with DriverApi =>\n  val commandTranslatedActor =\n    actorSystem.actorOf(CommandTranActor.commandTranProps, CNaming.timebasedName(\"CommandTran\"))\n\n  def processCommand(command: List[String], timeout: Timeout = longTimeout)(implicit\n      ex: ExecutionContext\n  ): Future[JobResult] = {\n    val commandJobMsg = JobMsg(\"SimpleCommand\", Json.toJson(CommandRequest(command)).toString())\n    val receiveActor =\n      actorSystem.actorOf(ReceiveActor.receiveActorProps, CNaming.timebasedName(\"Receive\"))\n    val commandJobRequest = JobRequest(commandJobMsg, receiveActor, commandTranslatedActor)\n    getProcessCommandFutureResult(commandJobRequest, defaultDriver, receiveActor, timeout)\n  }\n} ProcessTranApi package doracore.api\n\nimport doracore.core.msg.Job.{JobMsg, JobRequest, JobResult}\nimport doracore.tool.job.process.ProcessTranActor\nimport doracore.tool.receive.ReceiveActor\nimport doracore.util.ProcessService.ProcessCallMsg\n\nimport scala.concurrent.{ExecutionContext, Future}\nimport akka.util.Timeout\nimport doracore.util.CNaming\n\n/** For doradilla.api in Doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/4/24\n  */\ntrait ProcessTranApi extends AskProcessResult {\n  this: SystemApi with DriverApi =>\n  val processTranActor = actorSystem.actorOf(\n    ProcessTranActor.processTranActorProps,\n    CNaming.timebasedName(\"defaultProcessTranActor\")\n  )\n\n  def runProcessCommand(processCallMsg: ProcessCallMsg, timeout: Timeout = longTimeout)(implicit\n      ex: ExecutionContext\n  ): Future[JobResult] = {\n    val processJob = JobMsg(\"SimpleProcess\", processCallMsg)\n    val receiveActor =\n      actorSystem.actorOf(ReceiveActor.receiveActorProps, CNaming.timebasedName(\"Receive\"))\n    val processJobRequest = JobRequest(processJob, receiveActor, processTranActor)\n    getProcessCommandFutureResult(processJobRequest, defaultDriver, receiveActor, timeout)\n  }\n}","title":"What’s JobApi"},{"location":"/usage/namedjob.html","text":"","title":"Named job"},{"location":"/usage/namedjob.html#named-job","text":"","title":"Named job"},{"location":"/usage/namedjob.html#whats-named-job","text":"By default doradilla will create a cluster based JobApi to process anonymous job at initialization stage.\nWhen received a named job, the doradilla will create a named JobApi to handled the job.\nThe code implementation see Named job Runner:\nprivate def getNamedJobApi(jobName:String):JobApi={\n  namedJobApiMap.get(jobName) match {\n    case Some(jobApi) => jobApi\n    case _=> val jobApi: JobApi = new JobApi(Some( getActorSystem()))\n      namedJobApiMap +=(jobName ->jobApi)\n      jobApi\n  }\n}\n\ndef runNamedProcessCommand(processJob: JobMsg,\n                           jobName:String,\n                           timeout: Timeout = ConstVars.longTimeOut,\n                           priority: Option[Int] = None)(implicit ex: ExecutionContext): Future[JobResult] = {\n  val jobApi = getNamedJobApi(jobName)\n  val receiveActor = jobApi.actorSystem.actorOf(ReceiveActor.receiveActorProps, CNaming.timebasedName(\"Receive\"))\n  val processJobRequest = JobRequest(processJob, receiveActor, jobApi.processTranActor, priority)\n  getProcessCommandFutureResult(processJobRequest, jobApi.defaultDriver, receiveActor,timeout)\n}","title":"What’s named job"},{"location":"/usage/namedjob.html#usage","text":"package app\n\nimport doracore.ActorTestClass\nimport doracore.core.msg.Job.{JobMsg, JobStatus}\nimport doracore.core.msg.Job.JobStatus.JobStatus\nimport doracore.util.ProcessService.ProcessResult\nimport doracore.util.{ProcessService, ProcessServiceSpec}\nimport doracore.vars.ConstVars\nimport doradilla.back.BackendServer\nimport doradilla.conf.TestVars\nimport org.scalatest.Matchers\n\nimport scala.concurrent.Await\n\n/** For app in doradilla\n  * Created by whereby[Tao Zhou](187225577@qq.com) on 2019/12/14\n  */\nclass NamedJobRunnerSpec extends ActorTestClass with Matchers {\n  override protected def beforeAll(): Unit = {\n    super.beforeAll()\n    ProcessService.nameToClassOpt = ProcessServiceSpec.safeProcessServiceNameToClassOpt\n  }\n\n  import scala.concurrent.ExecutionContext.Implicits.global\n\n  val timeout = ConstVars.timeout1S * 4\n  \"Named Job Runner\" should {\n    \"start new driver when name is different\" in {\n      val job1 = TestVars.sleepProcessJob\n      BackendServer.runNamedProcessCommand(job1, \"job11\")\n      val job2         = TestVars.processJob\n      val resultFuture = BackendServer.runNamedProcessCommand(job2, \"job12\")\n      val result       = Await.ready(resultFuture, timeout)\n      println(result)\n    }\n\n    \"Named Job Runner\" should {\n      \"start new driver when name is different but will failed without fsm \" in {\n        val job1 = TestVars.sleepProcessJob\n        BackendServer.runNamedProcessCommand(job1, \"job1\")\n        val job2 = TestVars.processJob\n        BackendServer.changeFSMForNamedJob(\"job2\", -1)\n        val resultFuture = BackendServer.runNamedProcessCommand(job2, \"job2\")\n        var timeOut      = false\n        try {\n          val result = Await.ready(resultFuture, timeout)\n          println(result)\n        } catch {\n          case exception: Exception =>\n            timeOut = true\n            println(exception)\n        }\n        timeOut shouldBe (true)\n      }\n    }\n\n    \"use same driver when name same\" in {\n      println(\"Start same driver test\")\n      val job1          = TestVars.sleepProcessJob\n      val result1Future = BackendServer.runNamedProcessCommand(job1, \"job3\")\n      val job2          = TestVars.processJob\n      val resultFuture  = BackendServer.runNamedProcessCommand(job2, \"job3\")\n      var timeOut       = false\n\n      try {\n        val result2 = Await.result(result1Future, timeout)\n        result2.result.asInstanceOf[ProcessResult].jobStatus == JobStatus.Failed\n        timeOut = true //For the execution failed for first\n        val result = Await.result(resultFuture, timeout)\n        println(result)\n      } catch {\n        case exception: Exception =>\n          timeOut = true\n          println(exception)\n      }\n      println(\"end same driver test\")\n      timeOut shouldBe (true)\n    }\n\n    \"use same driver when name same with increased fsm \" in {\n      val job1 = TestVars.sleepProcessJob\n      BackendServer.changeFSMForNamedJob(\"job4\", 1)\n      val result1Future = BackendServer.runNamedProcessCommand(job1, \"job4\")\n      val job2          = TestVars.processJob\n      val resultFuture  = BackendServer.runNamedProcessCommand(job2, \"job4\")\n      var timeOut       = false\n\n      try {\n        val result = Await.ready(resultFuture, timeout)\n        println(result)\n      } catch {\n        case exception: Exception =>\n          timeOut = true\n          println(exception)\n      }\n      timeOut shouldBe (false)\n    }\n  }\n}","title":"Usage"},{"location":"/usage/namedjob.html#fsmactor-number-control-for-named-jobapi","text":"For named JobApi, there will create only one FSMActor, you can increase and decrease FSMActor by use api as below:\ndef changeFSMForNamedJob(jobName: String, num:Int)={\n  val jobApi = getNamedJobApi(jobName)\n  if(num >0){\n    jobApi.defaultDriver ! FSMIncrease(num)\n  }else{\n    jobApi.defaultDriver ! FSMDecrease(Math.abs(num))\n  }\n}","title":"FSMActor number control for named JobApi"},{"location":"/usage/usecase.html","text":"","title":"Use case"},{"location":"/usage/usecase.html#use-case","text":"","title":"Use case"},{"location":"/usage/usecase.html#jobapi-for-processor-control","text":"For document extraction project, the document will go through these processors as below:\nAnd each processor will occupy one CPU core. If the host machine has only 4 CPU cores, if you start 5 document procession at a time, the processors need at least 5 CPU cores.\nUse JobApi to set the workers number for driver will control the concurrent jobs as below:","title":"JobApi for processor control"},{"location":"/usage/usecase.html#named-job-usage","text":"For the same document processing project, the “OCR processor” is provided by 3rd-party vendor. So the “OCR processor” will not running on the same host with other processor.\nIf all processors use same JobAPi, when one worker is taking “OCR processor” job, then one CPU on the host will be not well utilized.\nSo the “OCR processor” could be assigned to another driver use the named job feature:\ndef runProcess(paras : List[AnyRef], clazzName:String, methodName:String, prioritySet: Option[Int] = None) ={\n    ....\n    val namedSevice = Seq(\"com.pwc.ds.cidr.project.creditreview.processors.OcrPlusProcessor\")\n    if(namedSevice.contains(clazzName)){\n      BackendServer.runNamedProcessCommand(jobMsg,OCRJOBStr, priority = prioritySet,timeout = setTimeOut).map{\n        ....\n    }else{\n      BackendServer.runProcessCommand(jobMsg,priority = prioritySet,timeout = setTimeOut).map{\n        ...\n    }\n  }\nand the processor as below:","title":"Named job usage"},{"location":"/configuration.html","text":"","title":"Configuration"},{"location":"/configuration.html#configuration","text":"","title":"Configuration"}]}